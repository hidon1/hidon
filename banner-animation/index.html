<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <title>חידון התנ״ך</title>
  <style>
    body {
      margin: 0;
      background: transparent !important;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: transparent !important;
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true // שקיפות מוחלטת
});
renderer.setClearColor(0x000000, 0); // רקע שקוף
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(3, 3, 3);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const loader = new THREE.TextureLoader();

const baseElements = [
  'menorah.png', 'circle2.png', 'circle1.png', 'shofar.png',
  'sparkle.png', 'leaves.png', 'cloud.png', 'star.png'
];

const duplicatedElements = [];
for (let i = 0; i < 3; i++) duplicatedElements.push(...baseElements);

const totalElements = duplicatedElements.length;
const iconSize = 1.15;
const bannerRadius = 1.5;
const radius = bannerRadius + (iconSize / 2) + 0.05;
const duration = 3000;

let group, rotationProgress = 0;
const totalRotation = Math.PI * 4;
const rotationSpeed = totalRotation / (duration / 16);
let stopRotation = false;
let arrivedCount = 0;

loader.load('images/quiz-center.png', (texture) => {
  texture.flipY = false;
  const material = new THREE.MeshStandardMaterial({
    map: texture,
    transparent: true,
    alphaTest: 0.5,
    side: THREE.DoubleSide
  });

  const geometry = new THREE.PlaneGeometry(4, 4);
  const front = new THREE.Mesh(geometry, material);
  front.scale.y = -1;

  const back = new THREE.Mesh(geometry, material.clone());
  back.scale.set(-1, -1, 1);
  back.position.z = -0.01;

  group = new THREE.Group();
  group.add(front);
  group.add(back);
  scene.add(group);

  const floatingGroup = new THREE.Group();
  scene.add(floatingGroup);

  duplicatedElements.forEach((src, i) => {
    loader.load("images/" + src, (tex) => {
      tex.flipY = false;
      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        depthWrite: false
      });
      const geo = new THREE.PlaneGeometry(iconSize, iconSize);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.scale.y = -1;

      const startX = (Math.random() - 0.5) * 20;
      const startY = (Math.random() - 0.5) * 20;
      const startZ = (Math.random() - 0.5) * 20;
      mesh.position.set(startX, startY, startZ);
      floatingGroup.add(mesh);

      const angle = (i / totalElements) * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      const z = 0;

      const startTime = performance.now();

      const animateIn = () => {
        const now = performance.now();
        const t = Math.min((now - startTime) / duration, 1);
        mesh.position.x = startX + (x - startX) * t;
        mesh.position.y = startY + (y - startY) * t;
        mesh.position.z = startZ + (z - startZ) * t;
        if (t < 1) {
          requestAnimationFrame(animateIn);
        } else {
          arrivedCount++;
          if (arrivedCount === totalElements) {
            stopRotation = true;
            group.rotation.y = 0;
          }
        }
      };
      animateIn();
    });
  });
});

function animate() {
  requestAnimationFrame(animate);
  if (group && !stopRotation && rotationProgress < totalRotation) {
    group.rotation.y += rotationSpeed;
    rotationProgress += rotationSpeed;
  }
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
